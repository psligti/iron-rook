# Learnings - Security FSM Prompt Tuning

This file records patterns, conventions, and successful approaches encountered during the security FSM implementation.

## ACT Phase Implementation (Phase 2)

### Task
Implement `_run_act()` method in `iron_rook/review/agents/security.py` with direct tool execution instead of delegating to subagents.

### Pattern Followed
The ACT phase follows the pattern from `SecuritySubagent._run_act()` in `security_subagent_dynamic.py`:

1. **Tool Execution Flow**:
   - Extract `tools_to_use` and `search_patterns` from delegate phase subagent_requests
   - Deduplicate tools and patterns using `dict.fromkeys()`
   - Execute each tool via dedicated `_execute_*()` methods
   - Collect results in a dictionary
   - Pass tool results to LLM for analysis

2. **Tool Execution Methods**:
   - `_execute_tools()`: Main dispatcher that routes to specific tool executors
   - `_execute_grep()`: Uses ripgrep for pattern search with file filtering (*.py, *.js, *.ts)
   - `_execute_read()`: Reads changed files up to 3000 characters each
   - `_execute_bandit()`: Runs bandit Python security linter with JSON output
   - `_execute_semgrep()`: Runs semgrep with auto config and JSON output

3. **Error Handling**:
   - Each tool executor catches exceptions and returns structured error messages
   - Timeout handling for long-running tools (30s for grep, 60s for bandit, 120s for semgrep)
   - FileNotFound handling for missing tools (returns "tool not available" message)

4. **Pattern Matching**:
   - `_get_default_patterns()`: Returns default security patterns (password, secret, api_key, etc.)
   - `_get_default_patterns_for_risk(risk_category)`: Returns patterns specific to risk category
   - Patterns organized by category: prompt_injection, injection, authn_authz, crypto, data_exposure, general

5. **FSM Integration**:
   - Updated `SECURITY_FSM_TRANSITIONS` to include "act" phase: delegate -> act -> collect
   - Updated `_phase_to_loop_state` mapping to include "act" -> LoopState.SYNTHESIZE
   - Added ACT phase handler in `review()` main loop
   - Updated `DELEGATE` phase instruction to transition to "act" instead of "collect"

### Key Design Decisions

1. **Direct Tool Execution vs Subagent Delegation**:
   - Phase 2 refactor moves from subagent delegation to direct tool execution
   - Reduces subagent overhead and simplifies the FSM flow
   - Maintains same tool execution pattern for consistency

2. **Tool Result Management**:
   - Tool results passed to LLM via `tool_results` dictionary in `_build_act_message()`
   - Results limited to prevent context overflow (3000 chars for read/bandit/semgrep, 2000 per grep pattern)
   - Pattern search limited to 5 patterns to prevent excessive output

3. **Pattern Extraction**:
   - Tools and patterns extracted from subagent_requests generated by DELEGATE phase
   - Risk category used to select appropriate patterns
   - Deduplication prevents redundant tool runs

### Success Patterns

1. **Consistent Tool API**:
   - All tool executors return `{"tool": "tool_name", "results": {...}}`
   - Error cases return structured error messages
   - Timeout and missing tool cases handled gracefully

2. **LLM Integration**:
   - `_build_act_message()` provides tool results to LLM
   - Instructions emphasize using ACTUAL evidence, not speculation
   - Findings required to be grounded in tool outputs

3. **Phase Transition Validation**:
   - FSM transitions validated against `SECURITY_FSM_TRANSITIONS`
   - Invalid transitions raise ValueError with helpful messages

### Dependencies Updated

- No new imports needed (subprocess, os already in use pattern from security_subagent_dynamic.py)
- Tools maintain same interface pattern for consistency

### Testing Considerations

- Tool executors handle missing tools gracefully (rg, bandit, semgrep optional)
- Timeout handling prevents indefinite hangs
- Pattern search limits prevent excessive output
- Error messages are structured for LLM analysis

---

## FSM Transition Updates (Phase 3)

### Task
Update `SECURITY_FSM_TRANSITIONS` dictionary and `_phase_to_loop_state` mapping in `iron_rook/review/agents/security.py` to support the new 5-phase structure.

### Changes Made

1. **FSM Transitions Structure**:
   - Old structure (6 phases): intake → plan_todos → delegate → act → collect → consolidate → evaluate → done
   - New structure (5 phases): intake → planning → act → synthesize → check → done

2. **Updated SECURITY_FSM_TRANSITIONS**:
   ```python
   SECURITY_FSM_TRANSITIONS = {
       "intake": ["planning"],
       "planning": ["act"],
       "act": ["synthesize"],
       "synthesize": ["check"],
       "check": ["done"],
   }
   ```

3. **Updated _phase_to_loop_state Mapping**:
   ```python
   self._phase_to_loop_state = {
       "intake": LoopState.INTAKE,
       "planning": LoopState.PLAN,
       "act": LoopState.ACT,
       "synthesize": LoopState.SYNTHESIZE,
       "check": LoopState.ACT,
       "done": LoopState.DONE,
   }
   ```

4. **Phase Handler Methods Added**:
   - `_run_synthesize()`: Merges and deduplicates findings from ACT phase (combines old collect + consolidate)
   - `_run_check()`: Assesses severity and generates final report (replaces old evaluate)
   - `_build_synthesize_message()`: Builds user message using ACT and PLANNING outputs
   - `_build_check_message()`: Builds user message using SYNTHESIZE output

5. **Phase-Specific Instructions Updated**:
   - INTAKE: Updated next_phase_request to "planning"
   - PLANNING: Renamed from PLAN_TODOS, updated to transition to "act"
   - ACT: Updated next_phase_request to "synthesize"
   - SYNTHESIZE: New instructions for merging/deduplicating findings
   - CHECK: New instructions adapted from old EVALUATE

### Key Design Decisions

1. **Phase Consolidation**:
   - COLLECT and CONSOLIDATE phases merged into SYNTHESIZE
   - Reduces phase count from 6 to 5
   - Simplifies FSM flow while maintaining functionality

2. **LoopState Mapping**:
   - "check" phase maps to LoopState.ACT (same as old "evaluate")
   - Consistent with the phase's purpose (evaluation/action)
   - No new LoopState values needed

3. **Backward Compatibility**:
   - Old phase methods (_run_delegate, _run_collect, _run_consolidate, _run_evaluate) kept in code
   - Old phase-specific instructions kept in dictionary
   - Allows gradual migration if needed

### Success Patterns

1. **FSM Validation Preserved**:
   - `_transition_to_phase()` continues to validate transitions against SECURITY_FSM_TRANSITIONS
   - Invalid transitions raise ValueError with helpful messages
   - No changes to validation logic required

2. **Phase Handler Consistency**:
   - All new phase handlers follow same pattern as old handlers
   - ThinkingFrame logging preserved
   - Phase-specific prompt retrieval unchanged

3. **Message Building**:
   - `_build_synthesize_message()` includes both PLANNING and ACT outputs for context
   - `_build_check_message()` uses SYNTHESIZE output for final assessment
   - Consistent with existing message building patterns

### LSP Diagnostics
- No errors or warnings after changes
- All new methods accessible
- FSM validation logic intact

### Testing Considerations
- FSM transitions validated by _transition_to_phase() method
- Phase outputs stored in _phase_outputs dictionary for later use
- Default transitions ensure forward progress even if next_phase_request is missing

---

## Phase Output Schema Updates (Phase 8 - Current Task)

### Task
Update phase output schemas in `iron_rook/review/contracts.py` to support new 5-phase structure.

### Changes Made

1. **Added New Phase Schemas**:
   - `ActPhaseOutput` and `ActPhaseData`: Tool execution phase
   - `SynthesizePhaseOutput` and `SynthesizePhaseData`: Findings consolidation phase
   - `CheckPhaseOutput` and `CheckPhaseData`: Final validation phase

2. **Removed Deprecated Schemas**:
   - `DelegatePhaseOutput` and `DelegatePhaseData` (old delegation-based approach)
   - References removed from `get_phase_output_schema()` function

3. **Updated get_phase_output_schema()**:
   - Phase names changed: "delegate", "collect", "consolidate", "evaluate" → "act", "synthesize", "check"
   - Docstring updated to reflect new phase names
   - `phase_schemas` dictionary updated with new mappings

### Schema Patterns

**ActPhaseData** (tool execution):
```python
tool_results: Dict[str, str]  # Tool execution results
findings_summary: List[str]   # Summary of findings
why: str                       # Rationale
```

**SynthesizePhaseData** (findings consolidation):
```python
findings: List[Dict[str, str]]  # Consolidated findings
evidence_index: List[str]       # Evidence references
why: str                       # Rationale
```

**CheckPhaseData** (final validation):
```python
gates: Dict[str, bool]         # Validation gates
confidence: float              # Confidence score (0.0-1.0)
why: str                       # Rationale
```

### Key Design Decisions

1. **Minimal Schema Changes**:
   - Followed existing pattern from IntakePhaseOutput and PlanTodosPhaseOutput
   - Each phase has Output (wrapper) and Data (actual content) models
   - Consistent field naming (phase, data, next_phase_request)

2. **Backward Compatibility**:
   - IntakePhaseOutput and PlanTodosPhaseOutput unchanged
   - CollectPhaseOutput, ConsolidatePhaseOutput, EvaluatePhaseOutput left in code
   - Only removed DelegatePhaseOutput which was specifically deprecated

3. **Schema Validation**:
   - All new schemas follow Pydantic BaseModel pattern
   - Literal types for phase names ensure type safety
   - Default factories for list/dict fields prevent shared mutable defaults

### Success Patterns

1. **Consistent Documentation**:
   - All phase schemas have docstrings following existing pattern
   - "Output model for X phase." and "Data model for X phase." format
   - Helps maintainability and documentation consistency

2. **Type Safety**:
   - Literal types for phase names prevent typos
   - Float confidence score has validation (0.0-1.0)
   - Optional fields properly typed with Optional or default_factory

3. **Schema Function Integration**:
   - `get_phase_output_schema()` returns JSON schema for prompt inclusion
   - Validated by LSP diagnostics (no errors)
   - Supports dynamic schema retrieval by phase name

### LSP Diagnostics
- No errors related to new schemas
- One pre-existing warning about deprecated `utcnow()` (unrelated to this task)
- All schemas accessible and properly typed

### Testing Considerations
- Schemas follow Pydantic validation rules
- JSON schema generation works via `model.model_json_schema()`
- Phase name validation enforced by Literal types
- Default factories prevent mutable default issues

### Verification
- LSP diagnostics clean for all new schemas
- Schemas follow existing pattern conventions
- `get_phase_output_schema()` function updated correctly
- No references to removed DelegatePhaseOutput in codebase
